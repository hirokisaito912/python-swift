# SwiftPython - Experiments in bridging Swift to Python.

![Icon](http://johnholdsworth.com/python_swift.png)

Contains a simple playground that uses a class "Complex" that is implemented in Python
from Swift. There are two [Auxiliary files](http://help.apple.com/xcode/mac/8.0/#/devfa5bea3af)
contained in the playground that perform the bridging:
"[PythonSupport.swift](SwiftPython.playground/Sources/PythonSupport.swift)" (most easily
viewed using the workspace) that contains a small set of generic support code for bridging and
"[Complex.swift](SwiftPython.playground/Sources/Complex.swift)" which performs the actual
bridging and would normally  be generated automatically by a python code generator script introspecting the
module. The underlying python implementation "[complex.py](SwiftPython.playground/Resources/complex.py)"
is included in the playground as a resource.

```Swift
//: Playground - noun: a place where people can play

import Foundation
var str = "Hello, python integration"

// This gives a stack trace when something out of the ordinary occurs
let _pythonWarn = pythonWarn
pythonWarn = {
    (_ message: String) in
    _pythonWarn(message)
    print(dumpStrackTrace())
}

// The basic class underlying the integration is PythonObject
PythonObject(any: "123").asString

// PythonObject can accept most Swift types specifically:
// Arrays, Dictionaries, Strings, Ints, Doubles and Data
let pythonObject = PythonObject(any: ["list": Array(0 ..< 100)])

// this is converted back to a concrete Swift type using "asAny(of:)"
let arrayDictionary = pythonObject.asAny(of: [String: [Int]].self)
print(arrayDictionary["list"]![4])

// You can leave the Object as Python structures to access it more efficiently
print(PythonDict<[Int]>(any: ["list": Array(0 ..< 100)])["list"]![4])
print(PythonDict<PythonList<Int>>(any: ["list": Array(0 ..< 100)])["list"]![4])

// PythonObject are passed to python methods and functions and returned.
// Class Complex is implemented in Python wrapped in auto-generated Swift code
// This Swift class is as wrapper generated by the script "bridgegen.py"
let c = Complex(realpart: 11.0, imagpart: 12.0)

// There are named and unnamed versions of initialisers and methods generated
c.add(c: Complex(1.0, 2.0))

// __doc__ comments in the Python class can specify the return type for "asAny"
print(c.toDictionary())

// global functions in the module are also exprted
print(newComplex(real: 123, imag: 456).toString(extra: c.toDictionary()))
print(newComplex(123, 456).toString(extra: c.toDictionary()))

// A closure or function can be used to have Python call back to Swift
c.callme(closure: {
    (args: [PythonObject]) -> PythonObject? in
    print(args[0].asString)
    return c
}, str: "Swift closure called from Python called from Swift")

func callback(args: [PythonObject]) -> PythonObject? {
    print(args[0].asString)
    return Complex(11.0, 22.0)
}

PythonObject(any: [c, c]).asAny(of: [Complex].self)[1]
    .callme(callback, "Swift function called from Python called from Swift")

// PythonList and PythonDict conform to Sequence

let list = PythonList<String>()
list.append("123")
list.append("234")
list.append("345")

// Setting an element at the end of a list is an implicit append
list[3] = "456"

for item in list {
    print(item)
}

let dict = PythonDict<Int>()
dict["ABC"] = 123
dict["DEF"] = 456

for (key, value) in dict {
    print("\(key): \(value)")
}

// Oddly, a PythonList can be initialised from PythonDict and vice versa
let dictAsList = PythonList<Any>(dictionary: dict).asTypeArray
PythonDict<Int>(array: dictAsList)

// Wherever possible conversion between types is available
let a1 = PythonObject(any: [1, 2, 3]).asArray(of: Int.self)
let a2 = PythonObject(any: [1, 2, 3]).asArray(of: Double.self)
let a3 = PythonObject(any: [1.5, 2.5, 3.5]).asArray(of: Int.self)
let a4 = PythonObject(any: [1.5, 2.5, 3.5]).asArray(of: Double.self)
let a5 = PythonObject(any: a4).asArray(of: String.self)
let a6 = PythonObject(any: a5).asArray(of: Double.self)
let d1 = PythonObject(any: ["a": 123, "b": 456]).asAny(of: [String: Int].self)

// "PythonAny" is SwiftyJSON-like omni-type useful for processing recursive data
PythonAny(any: ["a": 1.0, "b": 2.0, "c": [1,2,3]])["c"]?[1].asInt

// Finally, processing of large arrays of primitive type is optimised
let start = Date()
(c.echoArray(value: Array(0 ..< 1_000_000)).asAny(of: [Int].self))[1000]
print(Date().timeIntervalSince(start))
```

### Code generator

An example code generator [bridgegen.py](bridgegen.py) is included. Its first argument
is the module to be generated then an optional path to the module so python can find it and
Swift code will be printed to stdout. Use doc comments as shown in complex.py to control
the return type of functions or specify instance variables.
